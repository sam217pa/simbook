# Coalescent simulation using msprime {#usingmsprime}

Kelleher *et al.* [-@Kelleher2016-cb] described a new approach to simulating the coalescent with recombination taking advantage of tree sequence data structures (Chapter \@ref(treeseqs)).  They describe an open-source software package called `msprime`, which is an evolution of `ms` [@Hudson2002-oo], which is (or, was) the "industry standard" software for coalescent simulation for the better part of two decades.  Many authors (too many to cite here) have modified `ms` in various ways.  Doing so was often difficult for various reasons, but it was how a large number of researchers cut their teeth on learning how to implement coalescent models.  I think it is safe to say that those days are almost over--the performance improvements of `msprime` over `ms` means that the community is better off investing on code bases using tree sequences.  Further, Kelleher *et al.* [-@Kelleher2016-cb] cleverly decided to provide a command line interface to `msprime` that behaves exactly as `ms` does, meaning that a simple alias in a user's environment can update existing work flows.

Performance aside, the major benefit of `msprime` is that it is implemented as a Python library rather than as a command-line package. (The `mspms` program mentioned above is installed with `msprime` to provide a command-line interface to a subset of the package's functionality).  Abstracting out the operations into a set of library functions and objects has many advantages.  First, the interface is greatly simplified, especially for complex demographic models, which may now be built up in "chunks" of Python logic (and comments, too!).  Second, much of the analysis of the simulation can be done in-memory, completely avoiding the need to write output to files.  

This chapter is a short tour of `msprime`'s key features. I strongly encourage you to read the [manual](http://msprime.readthedocs.io), as well as a tutorial by Jerome Kelleher (CITATION when it comes out).  Much of the material here is complementary to the  "Tutorial" section of the [manual](http://msprime.readthedocs.io).


## Obtaining msprime

* [Source code](http://github.com/tskit-dev/msprime) is on github.
* The [manual](http://msprime.readthedocs.io) is auto-generated on Read The Docs.
* Binary builds for Linux and OS X are available from [conda-forge](https://anaconda.org/conda-forge/msprime).
* You may also install via `pip3`.

There are Docker images in the works for `msprime`, but I recommend `conda` for most users, as you have access to "everything" that way.

*Note*: `msprime` is a `python3` package.

## Running a simple simulation

```{python}
import msprime

# Simulate n=10 genomes
ts = msprime.simulate(10, mutation_rate=10.,
                      recombination_rate=10.)
```

The data type is a tree sequence:

```{python}
type(ts)
```

## Parameter scaling

By default, `msprime` uses a scaling of `N` generations in the Python package.  Parameters like the mutation and recombination rates are in these units.
Thus, the default "scaled mutation rate" is $N\mu$, where $\mu$ is the neutral mutation rate (per haploid genome, per generation), and the following two lines of code would give results that are identical in distribution when many replicates are run:

```{python}
import msprime

ts = msprime.simulate(10, mutation_rate=25.0)
tw2 = msprime.simulate(10, mutation_rate=0.25, Ne=100)
```

Figure \@ref(fig:msprimeScaling) shows the ECDF of the number of mutation from $10^4$ replicates of each command line, and you can see that they are right on top of one another.  The figure for the code is in \@ref(msprimescalingcode).

```{r, msprimeScaling, echo=FALSE, fig.cap="Parameter scaling in msprime"}
knitr::include_graphics("msprime_scaling.png")
```

For the examples shown above, `mutation_rate=25.0` implies $N\mu = 0.25$, and `mutation_rate=0.25` implies $0.01N\mu = 0.25$ as we are measuring time in units of $100N$ generations.  Many theory papers present results in units of $2N$ generations and `ms` scales time in units of `4N` generation.  You may set $Ne = 0.5$ or $0.25$, respectively, to obtain those scalings.

For example, if we want to model $\theta = 4N\mu = 100$ and $\rho = 4Nr = 100$, then the following are all equivalent:

```{python, eval=F}
theta, rho = 100.0, 100.0
ts = msprime.simulate(10,
                      mutation_rate=theta/4.,
                      recombination_rate=theta/4.)
ts = msprime.simulate(10,
                      mutation_rate=theta/2.,
                      recombination_rate=theta/2., Ne=0.5)
ts = msprime.simulate(10,
                      mutation_rate=theta,
                      recombination_rate=theta, Ne=0.25)
```

Let's take a look at the scaling at work.  We will also see how to run many simulation replicates sequentially, and see one scheme for reproducible seeding:

```{python, code=readLines("chapters/msprime/listings/scaling.py")}
```

In general, one of the biggest challenges that people have in applying simulations is in dealing with scaling differences between different simulation programs.  I almost always need to resort to pictures on a whiteboard to get the conversions right, especially between different programs.

## Demographic events

### Exponential growth

```{python}
config = [msprime.PopulationConfiguration(sample_size=10,
                                          initial_size=1,
                                          growth_rate=1e-4)]
ts = msprime.simulate(population_configurations=config,
                      random_seed=42)
```

### Discrete population size changes

```{python}
size_changes = [msprime.PopulationParametersChange(time=0.01,
                                                   initial_size=0.1,
                                                   population_id=0),
                msprime.PopulationParametersChange(time=0.025,
                                                   initial_size=1.0,
                                                   population_id=0)]
ts = msprime.simulate(10, random_seed=42,
                      demographic_events=size_changes)
```

### Multiple populations

Simulations with multiple demes require some forethought.  If we simply set a `config` variable listing sample sizes of different populations over time, we get an invalid model.  By default, there is no migration amongst the subpopulations, meaning an infinite time to the final coalescent event.

In the following block, `config` sets up two populations of 5 genomes each.  That is all--no migration, and the two populations never come into contact.  If we attempt to simulate with this model, `msprime` will raise an exception.  Fortunately, `msprime` contains a handy tool, `DemographyDebugger`, which prints out the model in rather plain terms.

```{python}
config = [msprime.PopulationConfiguration(sample_size=5),
          msprime.PopulationConfiguration(sample_size=5)]
dd = msprime.DemographyDebugger(population_configurations=config)
# In a regular Python session, dd.print_history()
# will write to the screen.  Here, however,
# I need to write to a file in order to
# get something that I may display in 
# this format:
with open('history.txt', 'w') as f:
    dd.print_history(f)
```

Taking a look at our history, we see two populations with no migration.  We cannot run this model:

```{r, code=readLines('history.txt'), eval=F}
```

The following adds in a "mass migration" event moving all of population one into population zero at three time units in the past:

```{python}
# Note: proportion = 1.0 is the default
demographic_events = [msprime.MassMigration(time=3.0,
                                            source=1,
                                            destination=0,
                                            proportion=1.0)]
dd = msprime.DemographyDebugger(population_configurations=config,
                                demographic_events=demographic_events)
with open('history.txt', 'w') as f:
    dd.print_history(f)
```

Our history log now shows the merge event, which gives us a valid model:

```{r, code=readLines('history.txt'), eval=F}
```

Now we have a valid model, which we can run to generate Figure \@ref(fig:multipops).  The code generating that figure is shown below,
where we also see some of `tskit`'s features for drawing trees.  (The SVG files are not easily incorporated into pdf or html output, so
we use the `convert` utility from [ImageMagick](http://www.imagemagick.org) to convert them to png.  This method is used for all of the trees
shown in this book.)

```{python, code=readLines("chapters/msprime/figures/multipops.py"), eval=F}
```

```{r multipops, echo=F, fig.cap="Genealogy of two demes without migration, with the populations merging $3N$ generations ago.  Node times are labelled.  A node colored black is found in population 0, and red refers to population 1."}
knitr::include_graphics("multipops.png")
```

#### Migration

We can easily set up migration matrices using `numpy`.  The diagonal elements must all be zero, and the off-diagonal values are the migration rates between subpopulations:

```{python}
m = np.zeros(4).reshape(2,2)
# This use of np.eye is a bit tricky,
# and worth working out what it is doing:
m[~np.eye(m.shape[0], dtype=bool)] = 1e-3

dd = msprime.DemographyDebugger(population_configurations=config,
                                migration_matrix=m)
with open('history.txt', 'w') as f:
    dd.print_history(f)
```

```{r, code=readLines('history.txt'), eval=F}
```

We may add in changes to the migration matrix:

```{python}
migchanges = [msprime.MigrationRateChange(time=0.5, rate=1e-6,
                                          matrix_index=(0,1))]
dd = msprime.DemographyDebugger(population_configurations=config,
                                migration_matrix=m,
                                demographic_events=migchanges)
with open('history.txt', 'w') as f:
    dd.print_history(f)
```

```{r, code=readLines('history.txt'), eval=F}
```

### Population splits and merges

This is a population split, thinking *forwards* in time:

```{python}
c = [msprime.PopulationConfiguration(5),
     msprime.PopulationConfiguration(5)]
d = [msprime.MassMigration(time=0.1,
                           source=1,
                           destination=0,
                           proportion=1.0)]
```

The next example is a population merge, where the ancestry of population 0 is 50% from population one, and
all of the final samples are from population zero. Note that we need some process, either continuous migration or an ancient 
"mass migration" event, in order to guarantee coalescence:

```{python}
c = [msprime.PopulationConfiguration(10),
     msprime.PopulationConfiguration(0)]
d = [msprime.MassMigration(time=0.1,
                           source=0,
                           destination=1,
                           proportion=0.5),
     msprime.MigrationRateChange(time=0.1, rate=1e-2)]
dd = msprime.DemographyDebugger(population_configurations=c,
                                demographic_events=d)
with open('history.txt', 'w') as f:
    dd.print_history(f)
```

```{r, code=readLines('history.txt'), eval=F}
```

A tree from this model is shown in Figure \@ref(fig:popsplit).

**TODO:** need to show diagrams of the model, and also discuss that business that we see in the debugger, which is that pop sizes are not affected by rates splits and merges, and what affect that may have.

```{r, popsplit, echo=FALSE, fig.cap="Genealogy of a population split model"}
knitr::include_graphics("popsplit.png")
```

## Ancient samples

## Non-uniform genetic maps

## Processing the genealogies

## Calculating statistics from simulated data

